{
	"slots": {
		"0": {
			"name": "core",
			"type": {
				"events": [],
				"methods": []
			}
		},
		"1": {
			"name": "atmofueltank_1",
			"type": {
				"events": [],
				"methods": []
			}
		},
		"2": {
			"name": "telefwd",
			"type": {
				"events": [],
				"methods": []
			}
		},
		"3": {
			"name": "teledown",
			"type": {
				"events": [],
				"methods": []
			}
		},
		"4": {
			"name": "slot5",
			"type": {
				"events": [],
				"methods": []
			}
		},
		"5": {
			"name": "slot6",
			"type": {
				"events": [],
				"methods": []
			}
		},
		"6": {
			"name": "slot7",
			"type": {
				"events": [],
				"methods": []
			}
		},
		"7": {
			"name": "slot8",
			"type": {
				"events": [],
				"methods": []
			}
		},
		"8": {
			"name": "slot9",
			"type": {
				"events": [],
				"methods": []
			}
		},
		"9": {
			"name": "slot10",
			"type": {
				"events": [],
				"methods": []
			}
		},
		"-1": {
			"name": "unit",
			"type": {
				"events": [],
				"methods": []
			}
		},
		"-2": {
			"name": "system",
			"type": {
				"events": [],
				"methods": []
			}
		},
		"-3": {
			"name": "library",
			"type": {
				"events": [],
				"methods": []
			}
		}
	},
	"handlers": [{
			"code": "---------------------------------------------------------------------------------\n--follower pet script, replace unit, start\n---------------------\ngvTicker = 0\ngvRandomMode = true --export\ngvShowHUD = false --export\n-- Debug helpers\nshowDebug = false --export\nlocal lastprint = \"\"\ngvDebugList = {}\n-- Fast string gluer\nfunction strAppend(buffer, ...)\n  for i = 1, select('#',...) do\n    local strval = select(i,...)\n    table.insert(buffer, strval)\n  end\nend\n\n-- Print to debug\nfunction debugp(...)\n  local buffer = {}\n  local tag = \"\"\n  table.insert(buffer, \"pet:\")\n  for i = 1, select('#',...) do\n    local strval = select(i,...) or \"nil\"\n    if i > 1 then\n      table.insert(buffer, \" \")\n    else\n      tag = strval\n    end\n    table.insert(buffer, tostring(strval))\n  end\n  table.insert(buffer, \".\")\n\n  local str = table.concat(buffer)\n  if showDebug and str and string.len(str) > 2 and tag ~= lastprint then\n    system.print(str)\n    system.logInfo(str)\n    lastprint = tag\n  end\n  if #gvDebugList > 10 then\n    table.remove(gvDebugList, 1)\n  end\n  strAppend(gvDebugList, str)\nend\n\ngvDefaultFloatDistance = 2.5 --export\ngvExtraLiftWhenMoving = 1.5 --export\ngvWonderingArea = 100 --export\ngvWonderingTime = 15 --export\ngvTooClose = 7 --export\ngvYawPID = pid.new(1, 0, 5)\ngvDownObstacle = 0\ngvYawInput = 0\ngvFloatDistance = gvDefaultFloatDistance\ngvStartPosition = vec3(core.getConstructWorldPos())\ngvRandomPosition = gvStartPosition\ngvOwnerLocalPos = vec3()\ngvRandomStartTicker = -500\nmath.randomseed (system.getTime() + gvStartPosition:len())\n\ngvOwnerYaw = vec3(0,0,0)\ngvOwnerAngle = 0\ngvOwnerDistance = 0\ngvVelocity = 0\nspeedKmh = 0\nspeedKmhPrevious = 0\ngvTurning = 0\ngvStoppedTick = 0\ngvMovingTick = 0\ngvAvoidTick = 0\ngvStopped = 1\ngvOnGround = 1\ngvComeDownNow = 0\ngvFwdObstacle = 0\ngvAvoiding = 0\ngvAvoidUntil = 0\ngvYawDamping = 0.02\ntargetAverage = 0\ntargetAverageIndex = 1\ntargetAverageSize = 40\ntargetAverageTable = {}\nfor i = 1, targetAverageSize do\n  table.insert(targetAverageTable, 0)\nend\n\nspeedAverage = 0\nspeedAverageIndex = 1\nspeedAverageSize = 40\nspeedAverageTable = {}\nfor i = 1, speedAverageSize do\n  table.insert(speedAverageTable, 0)\nend\n\nNav = Navigator.new(system, core, unit)\nNav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {2, 10, 50, 100})\nNav.axisCommandManager:setTargetGroundAltitude(0.5)\n\nunit.hide()\n\n-- Get individual axis controllers\ngvCmdLong =  Nav.axisCommandManager.axisCommands[axisCommandId.longitudinal]\ngvCmdSide =  Nav.axisCommandManager.axisCommands[axisCommandId.lateral]\ngvCmdVert =  Nav.axisCommandManager.axisCommands[axisCommandId.vertical]\nNav.axisCommandManager:setMasterMode(axisCommandType.byTargetSpeed)\n\n--if unit.isRemoteControlled() then\n--  system.freeze(1)\n--end\n\n-- Start the tick(follower) function ten times per second.\nself.setTimer(\"follower\", 0.1)\n\n-- Show the SCREEN widget. If you don't want the little status panel visible, \n-- comment out the following line.\nsystem.showScreen(1)\n\ndebugp(\"Started\")\n\n-- Function to generate html fragment for SCREEN widget about follower peting.\nfunction SetScreenFollower()\n    local page = {}\n    strAppend(page, [[\n<style type=\"text/css\">\n.screen_widget_wrapper .widget_header {display: none;}\n.du-header {color:black; background-color:white; width:200px; height:30px;}\n</style>\n<div class=\"du-header\">\n<div style=\"padding:4px; font-size: 16px; text-align:center;\">PET STATUS</div>\n</div>\n]])\n    -- gvOwnerLocalPos\n    --gvAvoiding\n    strAppend(page, \"<div><table>\")\n    strAppend(page, \"<tr><td>Angle:</td><td>\", string.format(\"%4.1f\", gvOwnerAngle * constants.rad2deg), \" d</td>\")\n    strAppend(page, \"<td>Owner:</td><td>\", string.format(\"%.0f\", gvOwnerLocalPos.x), \n\t  \"/\", string.format(\"%.0f\", gvOwnerLocalPos.y), \"/\", string.format(\"%.0f\", gvOwnerLocalPos.z), \n\t  \"</td></tr>\")\n\n    strAppend(page, \"<tr><td>Dist:</td><td>\", string.format(\"%4.1f\", gvOwnerDistance), \"m</td>\")\n    strAppend(page, \"<td>Obstacle:</td><td>\", string.format(\"%4.1f\", gvFwdObstacle), \"m</td></tr>\")\n\n    strAppend(page, \"<tr><td>Speed:</td><td>\", string.format(\"%4.1f\", gvVelocity), \"km/h</td>\")\n    strAppend(page, \"<td>Target:</td><td>\", string.format(\"%4.1f\", speedKmh), \"km/h</td></tr>\")\n\n    strAppend(page, \"<tr><td>Average:</td><td>\", string.format(\"%4.1f\", speedAverage), \"km/h</td>\")\n    strAppend(page, \"<td>Target:</td><td>\", string.format(\"%4.1f\", targetAverage), \"km/h</td></tr>\")\n\n\n    strAppend(page, \"<tr><td>Floats:</td><td>\", string.format(\"%4.1f\", gvDownObstacle), \"m</td>\")\n    strAppend(page, \"<td>Avoiding:</td><td>\", ((gvAvoiding == 1) and \"left\" or (gvAvoiding == -1) and \"right\" or \"no\"), \"</td></tr>\")\n\n    strAppend(page, \"<tr><td colspan=2>\")\n    if unit.getAtmosphereDensity() < 0.1 then\n        strAppend(page, \"need AIR! \")\n    end\n    if gvComeDownNow == 1 then\n        strAppend(page, \"Kneeling. \")\n    elseif gvStopped == 1 then\n        strAppend(page, \"Idle. \")\n    end\n    if brakeInput > 0 then\n        strAppend(page, \"Braking. \")\n    end\n    if gvOnGround == 1 then\n        strAppend(page, \"On ground. \")\n    end\n\n    strAppend(page, \"</td><td colspan=2>\", gvRandomMode and \"Random\" or \"Follower\", \" Alt+G toggles</td>\")    \n    \n    strAppend(page, \"</td></tr></table></div>\")\n    --\n    return table.concat(page)\nend\n\nfunction setLongSpeed(speedKmh)\n  if speedKmh ~= speedKmhPrevious then\n    --debugp(\"New speed\", speedKmh)\n    gvCmdLong:setCommandByTargetSpeed(speedKmh)\n    speedKmhPrevious = speedKmh\n  end\nend\n\nfunction setSideSpeed(speedKmh)\n  --debugp(\"New sidespeed\", speedKmh)\n  gvCmdSide:setCommandByTargetSpeed(speedKmh)\nend\n\ngvUnitInitialized = true\n-- end follower pet script\n---------------------------------------------------------------------------------\n",
			"filter": {
				"args": [],
				"signature": "start()",
				"slotKey": "-1"
			},
			"key": "0"
		}, {
			"code": "---------------------------------------------------------------------------------\n--- replace unit.stop()\n------------------\nself.stopTimer(\"follower\")\nsystem.setScreen(\"\")\nsystem.showScreen(0)    \n\n--\n-- End of follower pet script snippet\n---------------------------------------------------------------------------------\n",
			"filter": {
				"args": [],
				"signature": "stop()",
				"slotKey": "-1"
			},
			"key": "1"
		}, {
			"code": "---------------------------------------------------------------------------------\n--follower pet script, add new event tick(follower)\n--\n-- This tick function gets executed repeatedly ten times per second.\n-- The little intelligence the pet has is all here.\n--\ngvTicker = gvTicker + 1\n\nif gvTicker < 50 then\n  -- First seconds\n  if gvTicker < 30 then\n    return\n  end\n  if brakeInput > 0 then\n    brakeInput = brakeInput - 0.1\n  end\n  if brakeInput <= 0.01 then\n    brakeInput = 0\n  end\nend\n\nlocal worldVertical = vec3(core.getWorldVertical())\nlocal worldUp = vec3(core.getConstructWorldOrientationUp())\nlocal worldForward = vec3(core.getConstructWorldOrientationForward())\nlocal worldRight = vec3(core.getConstructWorldOrientationRight())\nlocal worldVelocity = vec3(core.getWorldVelocity())\nlocal worldVelocityDir = vec3(core.getWorldVelocity()):normalize()\nlocal worldAngularVelocity = vec3(core.getWorldAngularVelocity())\nlocal yawVelocity = worldAngularVelocity:dot(worldUp)\nlocal horizonForward = worldForward:project_on_plane(worldVertical)\nlocal horizonRight = worldRight:project_on_plane(worldVertical)\n\n\nlocal velocityVec = worldVelocity:project_on_plane(worldUp)\ngvVelocity = velocityVec:len() * 3.6\ngvForwardSpeed = velocityVec:project_on(horizonForward):len()\ngvRightSpeed = velocityVec:project_on(horizonRight):len()\n\nlocal degs90 = 90 * constants.deg2rad\nlocal degs60 = 60 * constants.deg2rad\nlocal degs5 = 5 * constants.deg2rad\n\nlocal pitchCurrent = worldForward:angle_between(horizonForward)\nif worldForward:angle_between(worldVertical) > degs90 then\n  pitchCurrent = -pitchCurrent\nend\nif math.abs(pitchCurrent) > degs5 and gvOnGround == 0 then\n  pitchInput = utils.clamp(pitchCurrent, -1, 1)\n  gvAvoiding = 1\nelse\n  pitchInput = 0\nend\n\nlocal rollCurrent = worldRight:angle_between(horizonRight)\nif worldRight:angle_between(worldVertical) > degs90 then\n  rollCurrent = -rollCurrent\nend\nif math.abs(rollCurrent) > degs5 and gvOnGround == 0 then\n  rollInput = utils.clamp(-rollCurrent, -1, 1)\n  gvAvoiding = rollCurrent > 0 and -1 or 1\n  setSideSpeed(0)\nelse\n  rollInput = 0\nend\nif math.abs(pitchCurrent) > degs60 or math.abs(rollCurrent) > degs60 then\n  debugp(\"I've fallen\", pitchCurrent, rollCurrent)\n  unit.exit()\nend\n\n-- Detect obstacle ahead\ngvFwdObstacle = 102\nif telefwd  ~= nil then\n  -- Make a safe call, in case telemeter is linked incorrectly.\n  local ok,distance = pcall(telefwd.getDistance, telefwd)\n  if not ok then\n    ok,distance = pcall(telefwd.distance, telefwd)\n  end\n  if ok and distance ~= -1 then\n    gvFwdObstacle = utils.round(distance, 0.1)\n  else\n    gvFwdObstacle = 101\n  end\nend\n\ngvDownObstacle = 102\nif teledown  ~= nil then\n  -- Make a safe call, in case telemeter is linked incorrectly.\n  local ok,distance = pcall(teledown.getDistance, teledown)\n  if not ok then\n      ok,distance = pcall(teledown.distance, teledown)\n  end\n  if ok and distance ~= -1 then\n      gvDownObstacle = utils.round(distance, 0.1)\n  else\n      gvDownObstacle = 101\n  end\nend\n\n--\n-- Calculate where owner is. \n-- Simplify physics and locations to horizontal angle, distance, and speed.\nlocal cwg = vec3(core.getConstructWorldPos())\nrealOwnerLocalPos = vec3(unit.getMasterPlayerRelativePosition())\n\nif gvRandomMode and realOwnerLocalPos:len() > 10 then\n  if (gvTicker - gvRandomStartTicker) > gvWonderingTime * 10 then\n   gvRandomStartTicker = gvTicker\n   local dist = gvStartPosition:dist(cwg)\n   local area = gvWonderingArea * 0.5 \n   if dist > area then\n     gvRandomPosition = gvStartPosition \n     debugp(\"Random, return to start\")\n   else\n     local randomVect = vec3(math.random (-area, area), math.random (-area, area), math.random (-area, area)):project_on_plane(worldVertical)\n     gvRandomPosition = gvRandomPosition + randomVect            \n     debugp(\"Random, new pos\", randomVect:len())\n   end\n  end\n  gvOwnerLocalPos = gvRandomPosition - cwg\nelse\n  gvOwnerLocalPos = realOwnerLocalPos\nend\ngvOwnerYaw = gvOwnerLocalPos:project_on_plane(worldUp)\ngvOwnerAngle= gvOwnerYaw:angle_between(worldForward)\nlocal rightAngle= gvOwnerYaw:angle_between(worldRight)\nif (rightAngle * constants.rad2deg) < 90 then\n  gvOwnerAngle = -gvOwnerAngle\nend\ngvOwnerDistance = gvOwnerYaw:len()\n\ngvYawPID:inject(gvOwnerAngle)\ngvYawInput = gvYawPID:get()\n\nlocal speedCheck = 1\nif targetAverage > 1.5 and speedKmh > 5 then\n  speedCheck = speedAverage / targetAverage\nend\nspeedKmh = 0\n\n\nif gvOwnerDistance < 6 then\n  debugp(\"state: very close\")\n  -- Freeze when close to owner\n  if gvTurning ~= 0 then\n    yawInput = 0\n    gvTurning = 0        \n  end\n  gvComeDownNow = 1\n  if gvTicker > 50 then\n    brakeInput = gvVelocity > 0.5 and 1 or 0\n  end\nelse\n  -- Decide movement\n    -- Not too close\n    gvComeDownNow = 0\n    if gvTicker > 50 and gvTicker > gvAvoidTick + 20 and brakeInput == 1 then\n      -- Reset brakes after stopping in front of obstacle\n      debugp(\"Obstacle brakes released\")\n      brakeInput = 0\n    end\n\n    if gvOwnerDistance < 10 then\n      debugp(\"state: idle\")\n      -- We are idling close by owner. Land if nothing happens for awhile.\n      gvAvoiding = 0\n      if gvStopped == 0 then\n        gvStopped = 1\n        gvFloatOffset = 0\n        gvStoppedTick = gvTicker\n      end\n    else\n      if gvStopped == 1 then\n        debugp(\"Getting up\")\n        -- Can't turn if landed. Get up.\n        gvStopped = 0\n        gvFloatDistance = Nav.axisCommandManager.targetGroundAltitude\n        gvMovingTick = gvTicker\n      end\n\n      if gvAvoiding == 0 then\n        if gvFwdObstacle < gvTooClose  or speedCheck < 0.3 then\n          -- Something is in front of us or blocking us. \n          -- Select randomly either left or right detour.\n          -- Pick randomly left or right.\n          gvAvoiding = gvTicker % 2\n          if gvAvoiding ~= 1 then\n            gvAvoiding = -1\n          end\n          gvAvoidTick = gvTicker\n          if speedCheck < 0.3 then\n            -- We are stuck but don't know how\n            gvAvoidUntil = gvTicker + 50\n          end\n          if gvFwdObstacle < gvTooClose then\n            brakeInput = 1\n          end\n          debugp(\"Obstacle ahead\", gvFwdObstacle, speedCheck, gvAvoiding)\n        else\n          gvFloatOffset = 0\n\n          -- Decide movement towards owner\n          local absAngle = math.abs(gvOwnerAngle) * constants.rad2deg\n          if  absAngle > 5 then\n            -- Rotate left/right until looking at owner.\n            speedKmh = 2\n            debugp(\"state: turning\", absAngle)\n          elseif gvDownObstacle > 1 then\n            if gvTicker > gvMovingTick + 50 then\n              speedKmh = utils.clamp((gvOwnerDistance - 10), 2, 30)\n            else\n              if gvTicker > gvMovingTick + 20 then\n                setSideSpeed(0)\n              end\n              speedKmh = 5\n            end\n            if  gvVelocity > 1 then\n              gvFloatOffset = utils.clamp(gvVelocity * 0.3, 0, gvExtraLiftWhenMoving)\n            end\n            debugp(\"state: moving\", speedKmh, gvFloatOffset)\n          end\n        end\n      else\n        -- We are avoiding an obstacle.\n        speedKmh = 0\n        if  gvFwdObstacle > gvTooClose * 1.2 + 2 and gvVelocity > 1 and gvTicker > gvAvoidUntil then\n          -- We got rid of the obstacle.\n          gvAvoiding = 0\n          gvMovingTick = gvTicker\n          debugp(\"Obstacle avoided\")\n        else\n          debugp(\"Obstacle avoiding\", gvAvoiding)\n          -- Continue random avoidance. \n          -- This pet isn't very smart and has only one eye...\n          if gvAvoiding == 1 then\n            setSideSpeed(-5)\n            if gvTicker % 60 == 0 and gvRightSpeed > -1 then\n              gvAvoiding = -1\n              debugp(\"Obstacle avoiding, switch to right\", gvAvoiding, gvRightSpeed)\n            end\n          elseif gvAvoiding == -1 then\n            setSideSpeed(5)\n            if gvTicker % 57 == 0 and gvRightSpeed < 1 then\n              gvAvoiding = 1\n              debugp(\"Obstacle avoiding, switch to left\", gvAvoiding, gvRightSpeed)\n            end\n          end\n          if gvTicker % 70 == 0 then\n            -- Try backing up too.\n            setSideSpeed(0)\n            speedKmh = -5\n              debugp(\"Obstacle avoiding, backing\", gvAvoiding)        \n          end\n          if gvTicker % 87 == 0 then\n            gvFloatOffset = 8\n\t\t  speedKmh = 5\n            debugp(\"Obstacle avoiding, jumping\", gvAvoiding)\n          end\n          if gvTicker % 167 == 0 then\n            gvFloatOffset = 0\n            debugp(\"Obstacle avoiding, puzzled\", gvAvoiding)\n          end\n        end\n      end\n    end\nend\n\n\nif gvStopped == 1 or gvComeDownNow == 1 then\n  if Nav.axisCommandManager.targetGroundAltitude > 0 and \n   (gvTicker - gvStoppedTick) > 100 or gvComeDownNow == 1 then\n    gvFloatDistance = gvFloatDistance - 0.1\n    Nav.axisCommandManager:setTargetGroundAltitude(gvFloatDistance)\n    debugp(\"Descending\", gvFloatDistance)\n  else\n    gvOnGround = 1\n  end\nelse\n  gvOnGround = 0\n  local floatDistance = gvDefaultFloatDistance + gvFloatOffset\n  local diff = floatDistance - Nav.axisCommandManager.targetGroundAltitude\n  if math.abs(diff) > 0.2 then\n    gvFloatDistance = gvFloatDistance + utils.clamp(diff, -0.1, 0.1)\n    Nav.axisCommandManager:setTargetGroundAltitude(gvFloatDistance)\n    debugp(\"Ascending\", gvFloatDistance, diff)\n  end\nend\n\n--[[\nif speedKmh == 0 and gvOnGround == 0 and math.abs(gvVelocity) > 1 then\n  brakeInput = 1\n  --debugp(\"Braking\")\nelseif brakeInput > 0 then\n  brakeInput = 0\n  --debugp(\"Stopping braking\")\nend\n--]]\n\nspeedAverageTable[speedAverageIndex] = gvVelocity\nspeedAverageIndex = speedAverageIndex + 1\nif speedAverageIndex > speedAverageSize then\n  speedAverageIndex = 1\nend\nlocal sum = 0\nfor i = 1, speedAverageSize do\n  sum = sum + speedAverageTable[i]\nend\nspeedAverage = sum / speedAverageSize\n\ntargetAverageTable[targetAverageIndex] = speedKmh\ntargetAverageIndex = targetAverageIndex + 1\nif targetAverageIndex > targetAverageSize then\n  targetAverageIndex = 1\nend\nlocal sum = 0\nfor i = 1, targetAverageSize do\n  sum = sum + targetAverageTable[i]\nend\ntargetAverage = sum / targetAverageSize\n\n-- end follower pet script\n---------------------------------------------------------------------------------\n",
			"filter": {
				"args": [{
						"value": "follower"
					}
				],
				"signature": "tick(timerId)",
				"slotKey": "-1"
			},
			"key": "2"
		}, {
			"code": "---------------------------------------------------------------------------------\n--follower pet script, replace system, start\n---------------------\n-- The code is compatible with DU A3.1 .\n-- \n-- Simple script to control a pet. This is intended for fun and education. \n--\n-- Features:\n-- - The pet keeps looking towards you. If it was moving, it stops and turns.\n-- - When closer than 5 meters it freezes itself. Asimov's robot rule 1.\n-- - When closer than 10 meters it idles. After awhile it sits down.\n-- - When further than 10 meters away it moves towards the owner.\n-- - When seeing an obstacle in front of itself it tries randomly to move around.\n-- - The pet shows a small info widget about its state.\n--\n-- This is not a smart pet. It's the bare-bones minimum implemetation. \n--\n-- Limitations:\n-- - This WILL do stupid things and will continue until shut down or runs\n--     out of fuel\n-- - The pet ignores vertical dimension.\n-- - Having only one telemeter to see is very limiting.\n-- - Collision avoidance is simplest possible. \n-- \n-- INSTRUCTIONS (assuming atmosphere):\n-- Build a pet as a hovership. \n-- Install remote controller.\n-- Install hover engine as usual.\n-- Install fuel tank as usual.\n-- Install adjustors as usual.\n-- Install atmo brake(s) as usual.\n-- Install four atmo engines shooting back, forward, right, and left. \n--   You can even skip left-, right-and forward-shooting engines, \n--   if you don't need obstacle avoiding. But if you leave them out\n--   the pet will just stare the obstacle forever.\n-- The engine shooting right should be tagged as \"strafeleft\". \n--   (right click, this element, tags)\n-- The engine shooting left should be tagged as \"straferight\".\n-- Install a telemeter or vbooster pointing forward and link it to RC and \n--   name the link \"telefwd\".\n-- Note: If the status screen shows obstable permanently *beyond* 100 \n--   meters, check your links!\n-- Install a telemeter or vbooster pointing down and link it to RC and \n--   name the link \"teledown\".\n-- In system, remove all actionstart, actionloop, and actionstop events, \n--   all of them. Leave only update and flush into system slot.\n-- Below are script snippets. The first comment line describes how the \n--   snippet should be installed.\n-- - \"Replace\" means you have to first delete whatever code there is.\n-- - \"Append\" means that leave whatever code there already is and paste \n--     new code after the existing code.\n-- - \"Add new\" means you need to create a new event into either system \n--     or unit. Then select the type, e.g. tick. If there is value in\n--     parenthesis like tick(follower), type that value \"follower\"\n--     next to the type \"tick\".\n---------------------------------------------------------------------------------\n\npitchInput = 0\nrollInput = 0\nyawInput = 0\nbrakeInput = 1\n\n-- end follower pet script\n---------------------------------------------------------------------------------\n",
			"filter": {
				"args": [],
				"signature": "start()",
				"slotKey": "-2"
			},
			"key": "3"
		}, {
			"code": "---------------------------------------------------------------------------------\n-- follower pet script, change marked places in system, flush\n-- - Flush exported parameters are not exported.\n-- - Changed \"final inputs\"\n-- - autoNavigationAcceleration modification to disable engines when onGround\n---------------------------------------------------------------------------------\n\n-- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu\n---------------------------------------------------------------------------------\n-- follower pet script, changed all --export: to --Xexport: to hide them from parameters\nlocal pitchSpeedFactor = 0.8 --Xexport: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal yawSpeedFactor =  1 --Xexport: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal rollSpeedFactor = 1.5 --Xexport: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n               \nlocal brakeSpeedFactor = 3 --Xexport: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01\nlocal brakeFlatFactor = 1 --Xexport: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal autoRoll = true --Xexport: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)\nlocal autoRollFactor = 2 --Xexport: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01\n\nlocal turnAssist = false --Xexport: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is\nlocal turnAssistFactor = 2 --Xexport: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01                             \n\n-- validate params\npitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)\nyawSpeedFactor = math.max(yawSpeedFactor, 0.01)\nrollSpeedFactor = math.max(rollSpeedFactor, 0.01)\ntorqueFactor = math.max(torqueFactor, 0.01)\nbrakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)\nbrakeFlatFactor = math.max(brakeFlatFactor, 0.01)\nautoRollFactor = math.max(autoRollFactor, 0.01)\nturnAssistFactor = math.max(turnAssistFactor, 0.01)\n\n-- final inputs\n---------------------------------------------------------------------------------\n-- follower pet script, changed\nlocal finalPitchInput = pitchInput or 0 --+ system.getControlDeviceForwardInput()\nlocal finalRollInput = rollInput or 0 --+ system.getControlDeviceYawInput()\nlocal finalYawInput = gvYawInput or 0 --yawInput - system.getControlDeviceLeftRightInput()\nlocal finalBrakeInput = brakeInput\n---------------------------------------------------------------------------------\n\n               \n-- Axis\nlocal worldVertical = vec3(core.getWorldVertical()) -- along gravity\nlocal constructUp = vec3(core.getConstructWorldOrientationUp())\nlocal constructForward = vec3(core.getConstructWorldOrientationForward())\nlocal constructRight = vec3(core.getConstructWorldOrientationRight())\nlocal constructVelocity = vec3(core.getWorldVelocity())\nlocal constructVelocityDir = vec3(core.getWorldVelocity()):normalize()\nlocal currentRollDeg = getRoll(worldVertical, constructForward, constructRight)\nlocal currentRollDegAbs = math.abs(currentRollDeg)\nlocal currentRollDegSign = utils.sign(currentRollDeg)\n\n-- Rotation\nlocal constructAngularVelocity = vec3(core.getWorldAngularVelocity())\nlocal targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight \n                                + finalRollInput * rollSpeedFactor * constructForward\n                                + finalYawInput * yawSpeedFactor * constructUp\n              \n-- In atmosphere?\nif worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then\n    local autoRollRollThreshold = 1.0\n    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling\n    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then\n        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit\n        if (rollPID == nil) then \n            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n        end\n        rollPID:inject(targetRollDeg - currentRollDeg)\n        local autoRollInput = rollPID:get()\n        \n        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward\n    end \n    local turnAssistRollThreshold = 20.0\n    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing\n    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then\n        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range\n        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range\n        \n        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)\n        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180\n        local rollVerticalRatio = 0\n        if rescaleRollDegAbs < 90 then\n            rollVerticalRatio = rescaleRollDegAbs / 90    \n        elseif rescaleRollDegAbs < 180 then\n            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90   \n        end\n        \n        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio\n        \n        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)\n        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio    \n                                \n        targetAngularVelocity = targetAngularVelocity \n                            + turnAssistPitchInput * constructRight \n                            + turnAssistYawInput * constructUp\n    end\nend\n\n-- Engine commands\nlocal keepCollinearity = 1 -- for easier reading\nlocal dontKeepCollinearity = 0 -- for easier reading\nlocal tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities\n\n-- Rotation\nlocal angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)\nlocal airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())\nangularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction                                            \nNav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\n-- Brakes\nlocal brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)\nNav:setEngineForceCommand('brake', brakeAcceleration)\n\n-- AutoNavigation regroups all the axis command by 'TargetSpeed'\nlocal autoNavigationEngineTags = ''\nlocal autoNavigationAcceleration = vec3()\nlocal autoNavigationUseBrake = false\n\n-- Longitudinal Translation\nlocal longitudinalEngineTags = 'thrust analog longitudinal'\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byThrottle) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)\n    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)           \nelseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration\n    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop\n        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking   \n    then\n        autoNavigationUseBrake = true\n    end\n    \nend\n\n-- Lateral Translation\nlocal lateralStrafeEngineTags = 'thrust analog lateral'\nlocal lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)\nif (lateralCommandType == axisCommandType.byThrottle) then\n    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)\n    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)                \nelseif  (lateralCommandType == axisCommandType.byTargetSpeed) then\n    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration\nend\n\n-- Vertical Translation\nlocal verticalStrafeEngineTags = 'thrust analog vertical'\nlocal verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)\nif (verticalCommandType == axisCommandType.byThrottle) then\n    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)\n    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)\nelseif  (verticalCommandType == axisCommandType.byTargetSpeed) then\n    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration\nend\n\n---------------------------------------------------------------------------------\n-- follower pet script, added\nif gvOnGround == 1 then\n  autoNavigationAcceleration = vec3()\n  Nav:setEngineForceCommand(autoNavigationEngineTags .. ', brake', autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\nend\n---------------------------------------------------------------------------------\n\n\n\n-- Auto Navigation (Cruise Control)\nif (autoNavigationAcceleration:len() > constants.epsilon) then               \n    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward\n    then\n        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'\n    end\n    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\nend\n\n-- Rockets\nNav:setBoosterCommand('rocket_engine')\n",
			"filter": {
				"args": [],
				"signature": "flush()",
				"slotKey": "-2"
			},
			"key": "4"
		}, {
			"code": "---------------------------------------------------------------------------------\n-- follower script, replace system, update\n-- If you don't want the little status panel visible, leave this away.\n--\nif gvUnitInitialized then\n  --Nav:update()\n  --Nav.axisCommandManager:setMasterMode(unit.getControlMasterModeId())\n  setLongSpeed(speedKmh)\n\n  if gvTicker % 10 == 0 and gvShowHUD then\n    -- Update screen once per every 20th tick(follower) call = 2 seconds\n    local str = \"<div>\"\n    str = str .. SetScreenFollower()\n    str = str .. \"</div>\"\n    system.setScreen(str)\n        \n  end\nend\n-- end follower script\n---------------------------------------------------------------------------------    \n\n",
			"filter": {
				"args": [],
				"signature": "update()",
				"slotKey": "-2"
			},
			"key": "5"
		}, {
			"code": "---------------------------------------------------------------------------------\n--follower pet script, add system, actionstart(antigravity)\n---------------------\ngvRandomMode = not gvRandomMode\ngvStartPosition = vec3(core.getConstructWorldPos())\n",
			"filter": {
				"args": [{
						"value": "antigravity"
					}
				],
				"signature": "actionStart(action)",
				"slotKey": "-2"
			},
			"key": "6"
		}, {
			"code": "gvShowHUD = not gvShowHUD\nsystem.showScreen(gvShowHUD and 1 or 0)",
			"filter": {
				"args": [{
						"value": "warp"
					}
				],
				"signature": "actionStart(action)",
				"slotKey": "-2"
			},
			"key": "7"
		}
	],
	"methods": [],
	"events": []
}
